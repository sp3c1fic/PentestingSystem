using PentestingSystem.Core.Contracts;
using System.Text.RegularExpressions;


namespace PentestingSystem.Core.Services
{
	public class PasswordStrengthCheckerService : IPasswordStrengthCheckerService
	{

        private const string CommonPasswordsFilePath = "/wwwroot/10-million-password-list-top-1000.txt";

        public IEnumerable<string> EstimatePasswordComposition(string password)
        {
            var composition = new List<string>();

            if (Regex.IsMatch(password, @"[A-Z]"))
                composition.Add("uppercase");
            if (Regex.IsMatch(password, @"[a-z]"))
                composition.Add($"lowercase");
            if (Regex.IsMatch(password, @"[0-9]"))
                composition.Add("numbers");
            if (Regex.IsMatch(password, @"[!@#$%^&*()_+|{}<>?.]"))
                composition.Add("symbols");
            if (Regex.IsMatch(password, @"^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*()_+|{}<>?.])"))
                composition.Add("symbols");

            return composition.Distinct();
        }

        public async Task<string> EvaluatePasswordStrength(string password)
        {
            var commonPasswords = await GetCommonPasswords();

            if (commonPasswords.Contains(password)) 
            {
                return "Weak";
            }
            
            if (LengthIsLessThanEight(password) && PasswordIsOnlyLowercase(password) ||
                LengthIsLessThanEight(password) && PasswordContainsOnlyDigits(password) ||
                LengthIsLessThanEight(password) && PasswordIsOnlySymbols(password))
            {
                return "Weak";
            }
            
            if (LengthIsLessThanEight(password) && PasswordIsOnlyUppercase(password))
            {
                return "Good";
            }
            
            if (LengthBetweenEightAndSixteen(password) && PasswordIsOnlyLowercase(password) ||
                     LengthBetweenEightAndSixteen(password) && PasswordContainsOnlyDigits(password) ||
                     LengthBetweenEightAndSixteen(password) && PasswordIsOnlySymbols(password))
            {
                return "Good";
            }

            if (LengthIsAtLeastSixteen(password) && Regex.IsMatch(password, @"[A-z0-9!@#$%^&*()_+|{}<>?.]+"))
            {
                return "Strong";
            }
            
            if (IsLongerThanRest(password) && Regex.IsMatch(password, @"[A-z0-9!@#$%^&*()_+|{}<>?.]+"))
            {
                return "Very Strong";
            }
           
            return "Good";
        }

        private async Task<string[]> GetCommonPasswords() 
        {
            var currentDirectory = Directory.GetCurrentDirectory();
            var fullPath = currentDirectory + CommonPasswordsFilePath;
            var passwords = await File.ReadAllLinesAsync(fullPath);
            return passwords;
        }

        private static bool LengthIsAtLeastSixteen(string password) 
        {
            return password.Length is >= 16 and <= 32;
        }

        private static bool PasswordIsOnlySymbols(string password) 
        {
            return Regex.IsMatch(password, @"^[!@#$%^&*()_+|{}<>?.]+$");
        }
        
        private static bool PasswordIsOnlyUppercase(string password)
        {
            return Regex.IsMatch(password, @"^[A-Z]+$");
        }

        private static bool PasswordIsOnlyLowercase(string password) 
        {
            return Regex.IsMatch(password, @"^[a-z]+$");
        }

        private static bool PasswordContainsOnlyDigits(string password) 
        {
            return Regex.IsMatch(password, @"[0-9]");
        }

        private static bool LengthIsLessThanEight(string password) 
        {
            return password.Length < 8;
        }

        private static bool LengthBetweenEightAndSixteen(string password) 
        {
            return password.Length is >= 8 and <= 16;
        }

        private static bool IsLongerThanRest(string password) 
        {
            return password.Length is >= 32 and <= 120;
        }

        public TimeSpan EstimateCrackingTime(string password, double attackerAttemptsPerSecond)
        {
            const int characterSetSize = 94;

            try
            {
                var entropyBits = Math.Log(Math.Pow(characterSetSize, password.Length), 2);
                var combinations = Math.Pow(characterSetSize, password.Length);
                var secondsToCrack = combinations / attackerAttemptsPerSecond;
                return TimeSpan.FromSeconds(secondsToCrack);
            }
            catch (OverflowException)
            {
                return TimeSpan.MaxValue;
            }
        }
    }


}

using PentestingSystem.Core.Contracts;
using System.Text.RegularExpressions;


namespace PentestingSystem.Core.Services
{
	public class PasswordStrengthCheckerService : IPasswordStrengthCheckerService
	{

        private const string _commonPasswordsFilePath = "\\wwwroot\\10-million-password-list-top-1000.txt";

        public IEnumerable<string> EstimatePasswordComposition(string password)
        {
            var composition = new List<string>();

            if (Regex.IsMatch(password, @"[A-Z]"))
                composition.Add("uppercase");
            if (Regex.IsMatch(password, @"[a-z]"))
                composition.Add($"lowercase");
            if (Regex.IsMatch(password, @"[0-9]"))
                composition.Add("numbers");
            if (Regex.IsMatch(password, @"[!@#$%^&*()_+|{}<>?.]"))
                composition.Add("symbols");
            if (Regex.IsMatch(password, @"^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*()_+|{}<>?.])"))
                composition.Add("symbols");

            return composition.Distinct();
        }

        public async Task<string> EvaluatePasswordStrength(string password)
        {
            var commonPasswords = await GetCommonPasswords();

            if (commonPasswords.Contains(password)) 
            {
                return "Weak";
            }
            else if (LengthIsLessThanEight(password) && PasswordIsOnlyLowercase(password) ||
                LengthIsLessThanEight(password) && PasswordContainsOnlyDigits(password) ||
                LengthIsLessThanEight(password) && PasswordIsOnlySymbols(password))
            {
                return "Weak";
            }
            else if (LengthIsLessThanEight(password) && PasswordIsOnlyUppercase(password))
            {
                return "Good";
            }
            else if (LengthBetweenEigthAndSixteen(password) && PasswordIsOnlyLowercase(password) ||
                     LengthBetweenEigthAndSixteen(password) && PasswordContainsOnlyDigits(password) ||
                     LengthBetweenEigthAndSixteen(password) && PasswordIsOnlySymbols(password))
            {
                return "Good";
            }

            else if (LengthIsAtLeastSixteen(password) && Regex.IsMatch(password, @"[A-z0-9!@#$%^&*()_+|{}<>?.]+"))
            {
                return "Strong";
            }
            else if (IsLongerThanRest(password) && Regex.IsMatch(password, @"[A-z0-9!@#$%^&*()_+|{}<>?.]+"))
            {
                return "Very Strong";
            }
           
            return "Good";
        }

        private async Task<string[]> GetCommonPasswords() 
        {
            var currentDirectory = Directory.GetCurrentDirectory();
            var fullPath = currentDirectory + _commonPasswordsFilePath;
            var passwords = await File.ReadAllLinesAsync(fullPath);
            return passwords;
        }

        private bool LengthIsAtLeastSixteen(string password) 
        {
            return password.Length >= 16 && password.Length <= 32;
        }

        private bool PasswordIsOnlySymbols(string password) 
        {
            return Regex.IsMatch(password, @"^[!@#$%^&*()_+|{}<>?.]+$");
        }
        
        private bool PasswordIsOnlyUppercase(string password)
        {
            return Regex.IsMatch(password, @"^[A-Z]+$");
        }

        private bool PasswordIsOnlyLowercase(string password) 
        {
            return Regex.IsMatch(password, @"^[a-z]+$");
        }

        private bool PasswordContainsOnlyDigits(string password) 
        {
            return Regex.IsMatch(password, @"[0-9]");
        }

        private bool LengthIsLessThanEight(string password) 
        {
            return password.Length < 8;
        }

        private bool LengthBetweenEigthAndSixteen(string password) 
        {
            return password.Length >= 8 && password.Length <= 16;
        }

        private bool IsLongerThanRest(string password) 
        {
            return password.Length >= 32 && password.Length <= 120;
        }

        public TimeSpan EstimateCrackingTime(string password, double attackerAttemptsPerSecond)
        {
            var characterSetSize = 94;
            var secondsToCrack = 0d;

            try
            {
                var entropyBits = Math.Log(Math.Pow(characterSetSize, password.Length), 2);
                var combinations = Math.Pow(characterSetSize, password.Length);
                secondsToCrack = combinations / attackerAttemptsPerSecond;
                return TimeSpan.FromSeconds(secondsToCrack);
            }
            catch (OverflowException)
            {
                return TimeSpan.MaxValue;
            }
        }
    }


}

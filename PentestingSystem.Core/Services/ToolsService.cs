using Microsoft.EntityFrameworkCore;
using System.Collections;
using System.Globalization;
using DnsClient.Protocol;
using PentestingSystem.Core.Models.Tools;
using PentestingSystem.Core.Contracts;
using PentestingSystem.Infrastructure.Data;
using PentestingSystem.Infrastructure.Extensions;
using PentestingSystem.Models.SSLCertificateChecker;


namespace PentestingSystem.Core.Services
{
    public class ToolsService : IToolsService
    {
        private readonly ApplicationDbContext _context;

        public ToolsService(ApplicationDbContext context)
        {
            _context = context;
        }
        public async Task<ICollection> GetToolNames()
        {
            var tools = await _context.Tools
                .Select(x => new ToolsServiceModel
                {
                    Name = x.Name,
                    
                })
                .ToListAsync();

            return tools;
        }

        public async Task<ToolsServiceModel> GetSpecificTool(string toolName)
        {
            var specificTool = await _context.Tools
                .Where(t => t.Name == toolName)
                .Select(t => new ToolsServiceModel
                {
                    Name = t.Name,
                    LongDescription = t.LongDescription
                })
                .FirstOrDefaultAsync();
            return specificTool!;
        }

        public async Task<IEnumerable<ToolsServiceModel>> GetMoreTools()
        {
            var moreTools = await _context.Tools
                .Select(t => new ToolsServiceModel
                {
                    Name = t.Name
                })
                .Take(10)
                .OrderDescending()
                .ToListAsync();

            return moreTools;
        }
        
        // TODO Move out into a separate service

        public async Task<SSLCertificateCheckerServiceModel> FetchCertificate(string domain)
        {
            var certificate = await CertificateDownloader.GetCertificateAsync(domain);

            if (certificate == null)
                throw new InvalidOperationException("Certificate cannot be null");

            var certificateValidity = certificate.NotAfter - certificate.NotBefore;

            var model = new SSLCertificateCheckerServiceModel
            {
                Host = domain,
                Url = domain,
                IssuedFor = domain,
                Version = certificate.Version,
                Subject = certificate.Subject,
                Issuer = certificate.Issuer,
                Validity = certificateValidity.Days,
                SerialNumber = certificate.SerialNumber,
                NotBefore = certificate.NotBefore.ToString(CultureInfo.InvariantCulture),
                NotAfter = certificate.NotAfter.ToString(CultureInfo.InvariantCulture),
                Algorithm = certificate.SignatureAlgorithm.FriendlyName!,
                Status = GetSslCertificateStatus(certificate.NotBefore, certificate.NotAfter)
                
            };
            

            return model;
        }

        private static string GetSslCertificateStatus(DateTime dateFrom, DateTime dateTo)
        {
            var comparison = DateTime.Compare(dateFrom, dateTo);
            return comparison is < 0 or 0 ? "Valid" : "Invalid";
        }

    }
}
